/* This code generates a plot to visualize performacne results saved to a given JSON file
 * generated by multidimensional_cosine_dft.c
 */
#define _DEFAULT_SOURCE
#define BUFFSIZE 4096
#define MAX_DIM_STR_LEN 200
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

struct PerformanceData{
/* Struct which holds performance data for a given run
 */
    int rank;
    int dims[100];
    double fs;
    int threads;
    double fft_gflops;
    double ifft_gflops;
    double fft_gflops_stdev;
    double ifft_gflops_stdev;
};

void plot_fft_and_ifft_results(struct PerformanceData *performance_results, int num_results);

int main(int argc, char* argv[]){

    // Make sure the user input a JSON document filename
    if (argc == 1){
        printf("No arguments were provided. Please pass in a JSON document filename.\n");
        exit(0);
    }

    char *json_filename = argv[1];

    // Check if the file exists. If it does, then open it. If it doesn't, then throw
    // an error letting the user know the file doesn't exist.
    if (access(json_filename, F_OK) != -1){

        // Array to save results to
        struct PerformanceData *performance_results = malloc(100 * sizeof(struct PerformanceData));

        // Open the JSON document
        FILE *json_file = fopen(json_filename, "r");

        // Create buffer
        char buffer[BUFFSIZE] = {'\0'};

        // Create tmp var for holding current character
        char current_char = '\0';

        // Iterating vars
        int i,j;

        // Temporary var to tell the algorithm when we should start reading
        bool start_reading;

        // For keeping track of the previous character
        char prev_char = '\0';

        // Rank parsing vars
        int *rank_ints = malloc(10 * sizeof(int));
        int rank_idx = -1;
        int rank_val = -1;
        int total_rank = 0;

        // Dims parsing vars
        int *dim_ints = malloc(100 * sizeof(int));
        int dim_idx = -1;
        int next_dim_idx = -1;
        int dim_val = -1;
        int total_dim = 0;
        int dim_number = 0;

        // Frequency parsing vars
        int *freq_mantissa_whole_number_ints = malloc(100 * sizeof(int));
        int *freq_mantissa_fraction_ints = malloc(2 * sizeof(int));
        int *freq_exponent_ints = malloc(2 * sizeof(int));
        int freq_mantissa_whole_idx = 0;
        int freq_mantissa_frac_idx = 0;
        int freq_exponent_idx = 0;
        double total_freq;
        int total_exponent;
        int exp_val;
        double freq_val = 0.0;
        bool start_fraction_parsing = false;
        bool start_exponent_parsing = false;
        int sign = -1;

        // Thread parsing vars
        int *thread_ints = malloc(5 * sizeof(int));
        int thread_idx = -1;
        int thread_val = -1;
        int total_threads = 0;

        // Forward DFT parsing vars
        int *fft_mantissa_ints = malloc(15 * sizeof(int));
        int *fft_fraction_ints = malloc(15 * sizeof(int));
        int fft_mantissa_idx = -1;
        int fft_fraction_idx = -1;
        double fft_val = 0.0;
        double total_fft_gflops = 0;
        bool start_fft_fraction = false;
        bool reached_fft = false;
        bool reached_fft_gflops = false;

        // Backward DFT parsing vars
        bool reached_ifft = false;
        bool reached_ifft_gflops = false;

        // Save index for performance results
        int performance_result_idx = -1;
        struct PerformanceData data;

        // Temp var for converting char to int
        int char_as_int;

        // Iterate
        while (fgets(buffer, BUFFSIZE, json_file)){

            // We don't need or want to process brackets
            if (buffer[0] == '{')
                continue;
            if (strstr(buffer, "}") != NULL)
                continue;

            // Prepare to create a new struct if we are at the "performance_results" heading
            if (strstr(buffer, "performance_results") != NULL){
                performance_result_idx++;
            }
            else if (strstr(buffer, "inputs") != NULL){
                continue;
            }
            else if (strstr(buffer, "rank") != NULL){
                start_reading = false;
                rank_idx = 0;
                rank_val = 0;
                total_rank = 0;
                for (i=0; i<BUFFSIZE; i++){

                    // Get the current character in the string
                    current_char = buffer[i];

                    // We want to start reading the numbers following the colon
                    if (current_char == ':')
                        start_reading = true;

                    // Once we're ready to start reading,
                    if (start_reading == true && current_char != '\0' && current_char != ' ' && current_char != ':' && current_char != ','){
                        char_as_int = (int)(current_char - '0');
                        rank_ints[rank_idx] = char_as_int;
                        rank_idx++;
                    }
                    else if (current_char == ','){
                        break;
                    }
                }

                // Now that we've filled our 'rank_ints' arr, let's get the rank
                for (i=0; i<rank_idx; i++){
                    rank_val = pow(rank_ints[i], rank_idx-i);
                    total_rank += rank_val;
                }
                data.rank = total_rank;
            }
            else if (strstr(buffer, "dims") != NULL){
                start_reading = false;
                dim_idx = 0;
                next_dim_idx = 0;
                total_dim = 0;
                dim_number = 0;
                for (i=0; i<BUFFSIZE; i++){

                    // Get the current character in the string
                    current_char = buffer[i];

                    // We want to start reading the numbers following the colon
                    if (current_char == ':')
                        start_reading = true;

                    // Once we're ready to start reading,
                    if (start_reading == true && current_char != ' ' && current_char != ':' && current_char != '[' && current_char != ']' && current_char != ',' ){
                        char_as_int = (int)(current_char - '0');
                        dim_ints[dim_idx] = char_as_int;
                        dim_idx++;
                    }
                    else if (start_reading == true && (current_char == ' ' || current_char == ',') && (prev_char == ',' || prev_char == ']')){
                        for (j=next_dim_idx; j<dim_idx; j++){
                            dim_val = dim_ints[j] * pow(10,dim_idx-j-1);
                            next_dim_idx++;
                            total_dim += dim_val;
                        }

                        data.dims[dim_number] = total_dim;
                        dim_number++;
                        total_dim = 0;
                    }

                    // If we've reached the ] character, then it means we've reached the end of the 'dims' array, so there's no
                    // need to continue iterating
                    if (prev_char == ']'){
                        break;
                    }

                    // Update prev character
                    prev_char = current_char;

                }
            }
            else if (strstr(buffer, "fs_Hz") != NULL){
                start_reading = false;
                start_fraction_parsing = false;
                start_exponent_parsing = false;
                freq_mantissa_whole_idx = 0;
                freq_mantissa_frac_idx = 0;
                freq_exponent_idx = 0;
                sign = 0;
                total_freq = 0;
                for (i=0; i<BUFFSIZE; i++){

                    // Get the current character in the string
                    current_char = buffer[i];

                    // We want to start reading the numbers following the colon
                    if (current_char == ':')
                        start_reading = true;
                    else if(current_char == '.')
                        start_fraction_parsing = true;
                    else if (current_char == 'e')
                        start_exponent_parsing = true;

                    char_as_int = (int)(current_char - '0');

                    // Once we're ready to start reading,
                    if (start_reading == true && current_char != ' ' && current_char != ':' && current_char != '.' && start_fraction_parsing == false && start_exponent_parsing == false){
                        freq_mantissa_whole_number_ints[freq_mantissa_whole_idx] = char_as_int;
                        freq_mantissa_whole_idx++;
                    }
                    else if (start_fraction_parsing == true && start_exponent_parsing == false && current_char != '.'){
                        freq_mantissa_fraction_ints[freq_mantissa_frac_idx] = char_as_int;
                        freq_mantissa_frac_idx++;
                    }
                    else if (start_exponent_parsing == true && current_char != 'e' && current_char != ','){

                        // Determine the sign of the exponent
                        if (current_char == '+'){
                            sign = 1;
                            continue;
                        }
                        else if (current_char == '-'){
                            sign = -1;
                            continue;
                        }

                        if (prev_char == '+' || prev_char == '-')
                            freq_exponent_ints[freq_exponent_idx] = sign * char_as_int;
                        else
                            freq_exponent_ints[freq_exponent_idx] = char_as_int;


                        // Keep track of the previous character. If the character is + or -, then we need to multiply 
                        // the current number by + or -
                        prev_char = current_char;

                        // Update idx
                        freq_exponent_idx++;

                    }
                    else if (current_char == ','){
                        break;
                    }
                }

                // prepare to capture the total frequency
                total_freq = 0.0;

                // Iterate through all of the integers in the mantissa whole number
                for (i=0; i<freq_mantissa_whole_idx; i++){
                    freq_val = freq_mantissa_whole_number_ints[i] * pow(10, freq_mantissa_whole_idx-i-1);
                    total_freq += freq_val;
                }

                // Iterate through all of the integers in the mantissa fraction
                for (i=0; i<freq_mantissa_frac_idx; i++){
                    freq_val = freq_mantissa_fraction_ints[i] * pow(10, -i-1);
                    total_freq += freq_val;
                }

                total_exponent = 0;
                for (i=0; i<freq_exponent_idx; i++){
                    exp_val = freq_exponent_ints[i] * pow(10, freq_exponent_idx-i-1);

                    if (freq_exponent_ints[0] > 0)
                        total_exponent += exp_val;
                    else
                        total_exponent -= exp_val;
                }

                // Update total frequency, for a final time
                total_freq = total_freq * pow(10, total_exponent);

                // Save
                data.fs = total_freq;
                
            }
            else if (strstr(buffer, "iterations") != NULL){
                continue;
            }
            else if (strstr(buffer, "threads") != NULL){
                start_reading = false;
                thread_idx = 0;
                total_threads = 0;
                total_fft_gflops = 0.0;
                for (i=0; i<BUFFSIZE; i++){

                    // Get the current character in the string
                    current_char = buffer[i];

                    // We want to start reading the numbers following the colon
                    if (current_char == ':')
                        start_reading = true;

                    if (start_reading == true && current_char == '\n')
                        break;

                    if (start_reading == true && current_char != ':' && current_char != ' '){
                        char_as_int = (int)(current_char - '0');
                        thread_ints[thread_idx] = char_as_int;
                        thread_idx++;
                    }
                }

                // Now that we've filled our 'thread_ints' arr, let's get the number of threads
                for (i=0; i<thread_idx; i++){
                    thread_val = thread_ints[i] * pow(10, thread_idx-i-1);
                    total_threads += thread_val;
                }

                // Save
                data.threads = total_threads;
            }
            else if (((reached_fft == true && reached_ifft == false) || (reached_fft == false && reached_ifft == true) || (reached_fft == true && reached_ifft == true)) && ((strstr(buffer, "average_gflops") != NULL) || strstr(buffer, "stdev_gflops") != NULL)){
                start_reading = false;
                fft_mantissa_idx = 0;
                fft_fraction_idx = 0;
                total_fft_gflops = 0;
                start_fft_fraction = false;                
                for (i=0; i<BUFFSIZE; i++){

                    // Get the current character in the string
                    current_char = buffer[i];

                    // We want to start reading the numbers following the colon
                    if (current_char == ':')
                        start_reading = true;

                    // The last character is either a comma (,) or a new line (\n)
                    if ((reached_fft_gflops == false || reached_ifft_gflops == false) && current_char == ',')
                        break;
                    else if (current_char == '\n')
                        break;

                    // If we've reached the . char, then it means we're ready to parse the fraction part
                    if (current_char == '.'){
                        start_fft_fraction = true;
                        continue;
                    }

                    if (start_reading == true && current_char != ':' && current_char != ' ' && start_fft_fraction == false){
                        char_as_int = (int)(current_char - '0');
                        fft_mantissa_ints[fft_mantissa_idx] = char_as_int;
                        fft_mantissa_idx++;
                    }
                    else if (start_reading == true && current_char != ':' && current_char != ' ' && start_fft_fraction == true){
                        char_as_int = (int)(current_char - '0');
                        fft_fraction_ints[fft_fraction_idx] = char_as_int;
                        fft_fraction_idx++;
                    }

                }

                // Now that we've filled our 'fft_mantissa_ints' and 'fft_fraction_ints' arrs, let's get the fft
                for (i=0; i<fft_mantissa_idx; i++){
                    fft_val = fft_mantissa_ints[i] * pow(10, fft_mantissa_idx-i-1);
                    total_fft_gflops += fft_val;
                }
                for (i=0; i<fft_fraction_idx; i++){
                    fft_val = fft_fraction_ints[i] * pow(10, -i-1);
                    total_fft_gflops += fft_val;
                }

                // Save results and set flags
                if (reached_fft == true && reached_ifft == false){

                    // Store FFT gflops
                    if (reached_fft_gflops == false){
                        data.fft_gflops = total_fft_gflops;
                        reached_fft_gflops = true;
                    }
                    else{
                        data.fft_gflops_stdev = total_fft_gflops;
                    }
                }
                else{

                    // Store IFFT gflops
                    if (reached_ifft_gflops == false){
                        data.ifft_gflops = total_fft_gflops;
                        reached_ifft_gflops = true;
                    }
                    else{
                        data.ifft_gflops_stdev = total_fft_gflops;
                        reached_ifft = false;
                        reached_fft = false;
                        reached_ifft_gflops = false;
                        reached_fft_gflops = false;
                    }
                }

            }
            else if (strstr(buffer, "forward_dft_results") != NULL){
                reached_fft = true;
                printf("REACHED_FFT, ");
            }
            else if (strstr(buffer, "backward_dft_results") != NULL){
                reached_ifft = true;
                printf("REACHED_IFFT\n");
            }

            // Store results to array
            if (performance_result_idx != -1)
                performance_results[performance_result_idx] = data;

            // Clear buffer
            for (i=0; i<BUFFSIZE; i++){
                buffer[i] = '\0';
            }
        }

        // Print parsed JSON
        struct PerformanceData tmp;
        printf("Parsed JSON data:\n\n");
        for (i=0; i<performance_result_idx+1; i++){
            tmp = performance_results[i];

            printf("%d Threads\n", tmp.threads);
            printf("    fs: %0.2e\n", tmp.fs);
            printf("    rank: %d\n", tmp.rank);
            printf("    dims: %d ", tmp.dims[0]);
            for (j=1; j<tmp.rank; j++){
                printf("x %d ", tmp.dims[j]);
            }
            printf("\n");
            printf("    fft_gflops: %0.3f +/- %0.3f\n", tmp.fft_gflops, tmp.fft_gflops_stdev);
            printf("    ifft_gflops: %0.3f +/- %0.3f\n", tmp.ifft_gflops, tmp.ifft_gflops_stdev);
        }

        plot_fft_and_ifft_results(performance_results, performance_result_idx+1);
    }
    else{
        printf("JSON document \"%s\" does not exist!", json_filename);
        exit(0);
    }

    return 0;
}

void plot_fft_and_ifft_results(struct PerformanceData *performance_results, int num_results){
/* Plot the FFT or IFFT results
 *
 *  Inputs
 *  ======
 *     struct PerformanceData *performance_results
 *         Array of PerformanceData results generated by the 'main' function
 *
 *     int num_results
 *        Number of results in *performance_results
 */


    // Iterative vars
    int i,j,k,m;

    // Tmp var for holding the data for the current iteration
    struct PerformanceData current_data;

    // Vars for plotting
    double fs = -1.0;
    int rank = -1;
    int max_threads = -1;
    int max_perf_time = -1;
    char dims_str[100] = {'\0'};

    // Tmp vars
    char current_char = 'z';
    char int_as_char[MAX_DIM_STR_LEN] = {'\0'};

    // Prepare to save to files. But because some operating systems don't allow for two files
    // to be open at the same time, we'll have to iterate through the same array twice, just
    // to be safe
    FILE *cosine_fft_performance_file = fopen("cosine_fft_performance.txt", "w");

    // Parse arr
    m = 0;
    double best_fft_perf_time = -1;
    double best_ifft_perf_time = -1;
    for (i=0; i<num_results; i++){
        
        // Grab current data
        current_data = performance_results[i];

        // Get fs and rank, and build dimensions string 'dims_str'
        if (i == 0){
            fs = current_data.fs;
            rank = current_data.rank;
            
            for (j=0; j<rank; j++){
                sprintf(int_as_char, "%d", current_data.dims[j]);
                k = 0;
                current_char = int_as_char[0];
                while (current_char != '\0'){
                    dims_str[m] = current_char;
                    k++;
                    m++;
                    current_char = int_as_char[k];
                }

                if (j < rank - 1){
                    dims_str[m] = ' ';
                    m++;
                    dims_str[m] = 'x';
                    m++;
                    dims_str[m] = ' ';
                    m++;
                }

                // Reset buffer
                for (k=0; k<MAX_DIM_STR_LEN; k++){
                    int_as_char[k] = '\0';
                }
            }
        }

        if (current_data.threads > max_threads)
            max_threads = current_data.threads;

        best_fft_perf_time = current_data.fft_gflops + current_data.fft_gflops_stdev;
        if (best_fft_perf_time > max_perf_time)
            max_perf_time = (int)ceil(best_fft_perf_time);

        best_ifft_perf_time = current_data.ifft_gflops + current_data.ifft_gflops_stdev;
        if (best_ifft_perf_time > max_perf_time)
            max_perf_time = (int)ceil(best_ifft_perf_time);

        // Save to 'cosine_performance.txt'
        fprintf(cosine_fft_performance_file, "%d %0.3f %0.3f\n", current_data.threads, current_data.fft_gflops, current_data.fft_gflops_stdev);
    }

    // Now do the IFFT results
    FILE *cosine_ifft_performance_file = fopen("cosine_ifft_performance.txt", "w");

    // Parse arr
    for (i=0; i<num_results; i++){
        
        // Grab current data
        current_data = performance_results[i];

        // Save to 'cosine_performance.txt'
        fprintf(cosine_ifft_performance_file, "%d %0.3f %0.3f\n", current_data.threads, current_data.ifft_gflops, current_data.ifft_gflops_stdev);
    }

    // Gnuplot vars
    char multiplot_layout[200];
    char *top_margin = "set tmargin screen 0.80";
    char *ygrid = "set grid ytics lc rgb \"#bbbbbb\" lw 1 lt 0";
    char *xgrid = "set grid xtics lc rgb \"#bbbbbb\" lw 1 lt 0";
    char *tics_scale = "set tics scale 0";
    char *fft_title = "set title \"Forward DFT\"";
    char *ifft_title = "set title \"Backward DFT\"";
    char *ylabel = "set ylabel 'Performance (GFlops)'";
    char *xlabel = "set xlabel '# of Threads'";
    char plot_fft[500];
    char plot_ifft[550];
    char set_yrange[30];
    char *set_key_off = "set key off";
    char *unset_multiplot  = "unset multiplot";
    char fs_label[60];
    char dims_label_text[m];
    char dims_label[200];

    // Fill 'multiplot_layout' title
    sprintf(multiplot_layout, "set multiplot layout 1, 2 title \"Discrete Fourier Transform Performance in GFlops (rank = %d)\" font \",14\"", rank);

    // Fill plot commands
    sprintf(plot_fft, "plot [1:%d] 'cosine_fft_performance.txt' using 1:2 with linespoints lc \"white\" lw 2,      '' using 1:2:2 with labels, \
     'cosine_fft_performance.txt' using 1:($2-$3)  with linespoints lc \"pink\", \
     'cosine_fft_performance.txt' using 1:($2+$3)  with linespoints lc \"pink\", \
     'cosine_fft_performance.txt' using 1:($2-$3):($2+$3) with filledcurves lc \"pink\" fs transparent solid 0.5, \
     'cosine_fft_performance.txt' using 1:2 with linespoints lc \"red\" lw 2,      '' using 1:2:2 with labels", max_threads);
    sprintf(plot_ifft, "plot [1:%d] 'cosine_ifft_performance.txt' using 1:2 with linespoints lc \"white\" lw 2,      '' using 1:2:2 with labels, \
     'cosine_ifft_performance.txt' using 1:($2-$3)  with linespoints lc \"skyblue\", \
     'cosine_ifft_performance.txt' using 1:($2+$3)  with linespoints lc \"skyblue\", \
     'cosine_ifft_performance.txt' using 1:($2-$3):($2+$3) with filledcurves lc \"skyblue\" fs transparent solid 0.5, \
     'cosine_ifft_performance.txt' using 1:2 with linespoints lc \"blue\" lw 2,      '' using 1:2:2 with labels", max_threads);
    
    //sprintf(plot_fft, "plot [1:%d] 'cosine_fft_performance.txt' using 1:2 with labels,      '' with linespoints lt rgb \"red\",      '', 'cosine_fft_performance.txt' using 1:($2-$3) with linespoints lc \"red\"", max_threads);
    //sprintf(plot_ifft, "plot [1:%d] 'cosine_fft_performance.txt' using 1:2 with labels,      '' with linespoints lt rgb \"red\",      '', 'cosine_fft_performance.txt' using 1:($2-$3) with linespoints lc \"red\"", max_threads);
    //sprintf(plot_ifft, "plot [1:%d] 'cosine_ifft_performance.txt' using 1:2 with labels,      '' with linespoints notitle lt rgb \"blue\"", max_threads);

    // Fill yrange command (max of both FFT and IFFT)
    sprintf(set_yrange, "set yrange [0:%d]", max_perf_time);

    // Fill dims label
    for (i=0; i<m; i++)
        dims_label_text[i] = dims_str[i];

    // Set sampling frequency label
    int fs_xval = floor(1 * max_threads / 2);
    int fs_yval = floor(2 * max_threads / 3);
    sprintf(fs_label, "set label 1 at %d, %d 'fs = %0.2e Hz", fs_xval, fs_yval, fs);

    // Set dims label
    int dims_y_offset = ceil(0.05 * fs_yval);
    char *tmp_test = dims_label_text;
    sprintf(dims_label, "set label 2 at %d, %d 'dims = %s' offset 0,%d", fs_xval, fs_yval, tmp_test, dims_y_offset);

    // Gnuplot commands
    char *gnuplot_cmds[] = {multiplot_layout, tics_scale, top_margin, fft_title, ylabel, xlabel, fs_label, dims_label, xgrid, ygrid, set_yrange, set_key_off, plot_fft, ifft_title, ylabel, xlabel, xgrid, ygrid, set_yrange, plot_ifft, unset_multiplot};

    // Now plot
    FILE *gnuplot_pipe = popen("gnuplot -persistent", "w");
    for (i=0; i<21; i++){
        fprintf(gnuplot_pipe, "%s \n", gnuplot_cmds[i]);
    }

}
